基本概念
    程序,进程,线程
        指令的集合->程序,是静态的对象
        程序的执行,运行的一个程序,产生,存在,消亡的过程进程是资源分配的单位,系统运行的时候会为每一个进程分配不同的内存区域
        进程可以进一步细化为线程,线程是一个程序内部的一条执行路径
            一个进程同事并行执行多个线程->支持多线程
            线程是调度和执行的最小单位,每个线程有独立的运行栈和程序计数器,线程切换的开销小
            一个进程中的多个线程共享相同的内存单元/内存地址空间,从同一堆中分配对象,可以访问相同变量和对象.
            线程之间通信简便高效.
            多个线程共享操作系统资源可能带来隐患.

    单核,多核cpu
        单核cpu->假的多线程
        多核cpu->最大化多线程效率

    一个java程序,最少有3个线程:
        main
        gc
        异常处理
        异常处理的时候,会影响主线程

    并行和并发
        并行:多个cpu同时执行多个任务,多个人做同多件事情
        并发:一个cpu同时(时间片)执行多个任务,多个人做同一件事情

    多线程优点:
        提高响应
        提高cpu利用率
        改善程序结构

    何时需要多线程:
        需要同时执行多任务
        需要实现一些等待的任务,比如用户输入,文件读写,网络多谢,搜索等
        需要后台运行

    线程创建和使用
    1，继承thread类的方式
         * 多线程创建1:继承thread类
         * 1,创建thread子类
         * 2,重写run方法
         * 3,实例化对象
         * 4,通过对象,调用start方法
    继承的方式,java的单继承,限制了其他继承

    2,实现runnable接口的方式
         * 创建多线程的方式二,实现runnable接口
         * 1,创建一个实现了runnable接口的类
         * 2,实现类,去实现runnable中的run方法
         * 3,创建实现了类的对象
         * 4,对象作为参数传递给thread类的构造器,创建thread类的对象
         * 5,通过thread类的对象调用start
         *
         * start 两个作用=1,启动线程;2,启动当前线程的run方法
         *
         * 想再启动一个线程呢
         * 再启动一个thread
     天然共享数据
     不会影响继承

    因此Runnable实现的方式更好

    联系:thread类,本身就实现了Runnable接口
    相同点:都要重写run方法,将线程要执行的逻辑声明在run方法中


    线程的生命周期
    Thread.State
    NEW
    RUNNABLE
    BLOCKED
    WAITING
    TIMED_WAITING
    TERMINATED

    新建:声明对象并创建
    就绪:新建状态的线程start,等cpu时间片
    运行:start
    阻塞:被认为挂起,cpu临时终止操作,金融阻塞
    死亡:线程完成工作,强制中止或异常结束

    线程同步
    卖票问题,怎么避免重复票的问题
    多个线程执行的不确定性引起执行结果的不稳定性
    多个线程对账本的共享,会造成操作的不完整性,破坏数据

    出现的原因:
        某个线程操作过程中,尚未完成,就被其他线程插入一脚,导致安全事故
        如何解决?线程锁
        java中线程锁的实现
            通过同步机制,来解决线程安全问题
            1,同步代码块
            synchronized(同步监视器){
                // 需要被同步的代码,也就是操作共享数据的代码
            }
            共享数据:多线程共同操作的变量,比如ticket就是共享数据
            实现runnable接口创建多线程的方式中,可以考虑用this充当同步监视器
            继承thread类创建多线程的方式中,慎重this充当同步监视器,可以考虑使用当前类做监视器
            2,同步方法
            操作共享数据的代码完整的声明在一个方法中,不妨将此方法声明同步

        死锁:
            不同线程分别占用对方资源,无法释放

        线程的锁,显式定义同步锁,来实现同步.同步锁使用lock对象充当.
        lock接口是控制多个线程,对共享资源进行访问的工具.锁提供了对共享资源的独占访问,每次只能有一个线程对lock对象加锁
        线程开始访问共享资源之前应该先获得lock对象

        reentrantlock 类实现了lock,拥有与synchronized相同的并发性和内存语义,
        在实现线程安全的控制中,常用的是reentrantlock,可以显式加锁,释放锁
    线程通信
