原型模式
    克隆羊的案例
    传统方式解决克隆羊问题:
        优点是比较容易理解,简单容易操作
        缺点是,创建新对象的时候,总是需要重新获取原始对象的属性,如果创建的对象比较复杂,效率会低下
        缺点还有,总是需要重新初始化对象,而不是动态获得对象运行时的状态,不够灵活

    改进思路:
        java中有一个object类,有clone方法,可以将对象复制一份
        但是需要实现clone的java类,需要实现cloneable接口,表示能够克隆->原型模式


    原型实例:
        用原型实例,指定创建对象的种类,通过拷贝这些原型创建对象
        是创建型设计模式,允许一个对象再创建另外一个可以定制的对象,无需知道如何创建的细节
        工作原理:通过将一个原型对象传给哪个需要发动创建的对象,要发动创建的对象通过请求原型对象拷贝他们自己来实施创建,即对象.clone()

    spring 框架中的分析

原型模式中,深浅拷贝的问题
    对象克隆的时候,会如何处理?复制一份?还是引用? 对象的引用,指向同一个对象罢了

    浅拷贝:
        对于数据类型,是基本数据类型的成员变量,浅拷贝->直接进行值传递,将该属性值,复制一份,给新的对象
        对于数据类型,是引用数据类型的成员变量,比如说,成员变量是某个数组,类的对象等,浅拷贝->引用传递,只是将该成员变量的引用值复制一下
            实际上两个对象的该成员变量,都指向同一个实例
            这种情况下,一个对象中,修改该成员变量,会影响到另一个对象的该成员变量的值

    深拷贝
        复制对象的所有基本数据类型的成员变量值
        为所有引用数据类型的成员申请存储空间,并且复制每个引用数据类型变量所引用的对象,直到该对象可达所有对象
        也就是说,深拷贝需要对整个对象进行拷贝

        实现方式:
            克隆
            序列化

    注意事项和细节
        1,创建新的对象比较负责的时候,可以用原型设计模式简化对象的创建过程,同时提高效率
        2,不用重新初始化对象,而是动态获得对象运行时的状态
        3,如果原始对象发生变化(增加或者减少属性),其他克隆对象的也会发生相应的变化,无需修改代码
        4,申客隆的时候,可能需要复杂代码
    缺点:需要为每个类配置一个克隆方法,对于新类不难,但是对于已有的类改造时,需要修改代码,违背了ocp原则