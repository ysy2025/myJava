代理模式:
    代理模式:为一个对象提供一个替身,以控制对这个对象的访问,即通过代理对象范文目标对象,好处是,可以在目标对象实现的基础上,增强额外的功能操作,扩展目标对象的功能.
    被代理的对象,可以是远程对象,创建开销大的对象,或者需要安全控制的对象
    代理模式的形式:静态代理,动态代理(JDK代理),Cglib代理(可以在内存中,动态创建对象,而不需要实现接口,属于动态代理的范畴)
    代理模式

静态代理模式在使用时,需要定义接口,或者父类,被代理对象,即目标对象,与代理对象一起,实现相同的接口,或者继承相同的父类

    优点:不修改目标对象的功能前提下,通过代理对象,对目标功能扩展
    缺点:代理对象需要与目标对象实现一样的接口,所以会有很多代理类;
    一旦接口增加方法,目标对象与代理对象就都要维护.

动态代理模式基本介绍
    1,代理对象,不需要实现接口,但是目标对象要实现接口,否则不能用动态代理
    2,代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象
    3,动态代理也叫做JDK代理,接口代理

JDK中生成代理对象的API
    代理类所在包:java.lang.reflect.Proxy
    JDK实现代理,只要使用 newProxyInstance 方法,但是该方法需要接收三个参数
    static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)

cglib 代理模式的基本介绍
    静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何接口,这个时候可以使用目标对象子类来实现代理
    cglib,也叫子类代理,内存中构建一个子类对象,从而实现对目标对象功能扩展
    cglib是一个强大的高性能的代码生成包,可以在运行器件,扩展java类,实现java接口
    cglib底层是通过字节码,处理框架ASM,来转换字节码,生成新类